### 代码随想录刷题笔记

一刷中：2022.10.10

------

#### I. 数组

#### 1. 二分查找

该类问题分为两种场景：

- 简单二分查找：数组有序，并且数组中无重复元素，存在两种模板：

  - 第一种[left, Right]，这种好理解，常用这种

    ```java
    public int search(int[] nums, int target) {
        int left = 0 , right = nums.length - 1;
        while (left <= right){
            int mid = (right - left) / 2 + left;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else {
                right = mid - 1;
            }
        }
        return -1;
    }
    ```

  - 第二种[left, Right)

    ```java
    public int search2(int[] nums, int target) {
        int left = 0 , right = nums.length;
        while (left < right){
            int mid = (right - left) / 2 + left;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else {
                right = mid;
            }
        }
        return -1;
    }
    ```

- 二分查找左右界：数组有序，但是有重复元素，寻找target的最小（大）下标

  寻找下标的时候会出现三种情况：

  - nums = {5, 7, 7, 8, 8, 10}， target = 4or12，即target不在nums区间内，返回-1

  - nums = {5, 7, 7, 8, 8, 10}， target = 6，即target在nums区间内，但无匹配，返回-1
  - nums = {5, 7, 7, 8, 8, 10}， target = 8，返回3

  这里以寻找左边界为例，寻找有边界同理

  ```java
      public int getLeftBorder(int[] nums, int target) {
          int left = 0, right = nums.length - 1, res = -1;
          while(left <= right){
              int mid = (right - left) / 2 + left;
              //[5, 7, 7, 7, 8, 8, 10] l = 0 , r = 6 , m = 3 , tar = 7
              //由于要找左边界，所以nums[m] == tars时还要继续寻找左区间，故r = m - 1
              if(nums[mid] >= target){
                  //因为要寻找左边界，需要更新right，寻找左区间
                  right = mid - 1;
                  res = right;
              }else {
                  left = mid + 1;
              }
          }
          if(res + 1 >= 0 && res + 1 <= nums.length - 1 && nums[res + 1] == target){
              return res + 1;
          }else {
              return -1;
          }
      }
  ```


#### 2. 常用方法

##### 2.1 二分法

使用场景：给出一组有序的数组，**根据条件寻找某个（些）元素**

一般可以用二分法加速元素的查询，时间复杂度O(n^2)

##### 2.2 双指针

使用场景：**删除数组中的元素**，要求空间复杂度为O(1)

利用双指针，left指针为要覆盖的位置，right为探索指针，寻找位置为符合要求的元素，将right位置上的元素赋值给left位置，后移指针

##### 2.3 滑动窗口

使用场景：**寻找满足条件的子数组**

利用双指针确定一个窗口，通过双指针的移动，实现滑动窗口，在窗口不断的滑动（扩大并缩小）寻求满足条件的子数组

#### II. 链表

链表一般设计到一下几类题型：

- 移除链表元素：可以利用迭代以及递归的方式实现

- 设计链表：该链表可以满足在任意位置添加节点，删除指定val的节点

  - 可以通过单链表或双向链表作为底层数据结构
  - 单链表：实时维护链表的长度size，用于判定index合法性
  - 双向链表：空间换时间，维护一个头节点一个尾节点，可以根据index的位置从头或尾进行遍历，加快查询速率

- 翻转链表

  - 利用栈实现

    ```java
    	public ListNode reverseList(ListNode head) {
            Stack<ListNode> stack = new Stack<>();
            ListNode newRoot = new ListNode(0);
            ListNode temp = newRoot;
            while(head != null){
                stack.add(head);
                head = head.next;
            }
            while(!stack.isEmpty()){
                temp.next = stack.pop();
                temp = temp.next;
            }
            //不加这句会导致循环链表
            //在栈中的节点next会保存之间的next，需要初始化
            temp.next = null;
            return newRoot.next;
        }
    ```

  - 迭代方法

    ```java
    	public ListNode reverseList2(ListNode head) {
            ListNode cur = head;
            ListNode pre = null;
            while(cur != null){
                //需要暂存一下cur的下一个节点
                ListNode next = cur.next;
                //翻转指针
                cur.next = pre;
                //后移pre以及cur
                pre = cur;
                cur = next;
            }
            return pre;
        }
    ```

  - 递归方法

    ```java
    	public ListNode reverseList3(ListNode head) {
            if(head == null || head.next == null){
                return head;
            }
            ListNode newRoot = reverseList3(head.next);
            //l1 -> l2 翻转为 l1 <- l2
            head.next.next = head;
            //去引用，初始化
            head.next = null;
            return newRoot;
        }
    ```

- 两两交换链表中的节点

  - 可以通过迭代和递归的方式解决，核心代码类似于翻转链表

- 删除链表中的倒数第N个节点

  - 该类问题可以用**双指针**解决，具体思路为：first指针与second指针相隔n个距离，后同时移动双指针，当first遍历到尾部时，second.next位置即为删除位置

    ```java
    public ListNode removeNthFromEnd2(ListNode head, int n) {
            ListNode newRoot = new ListNode(-1);
            newRoot.next = head;
            ListNode first = head;
            ListNode second = newRoot;
            for(int i = 0; i < n; i++){
                first = first.next;
            }
            while(first != null){
                first = first.next;
                second = second.next;
            }
            second.next = second.next.next;
            return newRoot.next;
        }
    ```

- 寻找两链表相交的首节点

  - 该类问题可以用**双指针**解决，设立双指针分别指向headA与headB，指针tempA遍历完headA，再遍历headB；同时，指针tempB遍历完headB，再遍历headA，当指针重合时，即重合点

  - 理论：设headA链表长a，headB链表长b，重合部分长c；则 a + (b - c) = b + (a - c)

    ```java
    	public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
            ListNode tempA = headA, tempB = headB;
            while(tempA != tempB){
                tempA = tempA == null ? headB : tempA.next;
                tempB = tempB == null ? headA : tempB.next;
            }
            return tempA;
        }
    ```

- 环形链表：寻找环入口

  - 该类问题可以用**双指针**解决，算法流程为：

    - 寻找第一次相遇位置（若有环存在）
    - slow继续从相遇位置移动，fast从链表头移动，同时一个一个移动，相遇位置为环入口

    ```java
    	public ListNode detectCycle3(ListNode head) {
            ListNode fast = head, slow = head;
            while(true) {
                if(fast == null || fast.next == null) {
                    return null;
                }
                fast = fast.next.next;
                slow = slow.next;
                if(slow == fast) break;
            }
            fast = head;
            while(slow != fast){
                slow = slow.next;
                fast = fast.next;
            }
            return fast;
        }
    ```

    