### 代码随想录刷题笔记

一刷中：2022.10.10

------

#### I. 数组

#### 1. 二分查找

该类问题分为两种场景：

- 简单二分查找：数组有序，并且数组中无重复元素，存在两种模板：

  - 第一种[left, Right]，这种好理解，常用这种

    ```java
    public int search(int[] nums, int target) {
        int left = 0 , right = nums.length - 1;
        while (left <= right){
            int mid = (right - left) / 2 + left;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else {
                right = mid - 1;
            }
        }
        return -1;
    }
    ```

  - 第二种[left, Right)

    ```java
    public int search2(int[] nums, int target) {
        int left = 0 , right = nums.length;
        while (left < right){
            int mid = (right - left) / 2 + left;
            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else {
                right = mid;
            }
        }
        return -1;
    }
    ```

- 二分查找左右界：数组有序，但是有重复元素，寻找target的最小（大）下标

  寻找下标的时候会出现三种情况：

  - nums = {5, 7, 7, 8, 8, 10}， target = 4or12，即target不在nums区间内，返回-1

  - nums = {5, 7, 7, 8, 8, 10}， target = 6，即target在nums区间内，但无匹配，返回-1
  - nums = {5, 7, 7, 8, 8, 10}， target = 8，返回3

  这里以寻找左边界为例，寻找有边界同理

  ```java
      public int getLeftBorder(int[] nums, int target) {
          int left = 0, right = nums.length - 1, res = -1;
          while(left <= right){
              int mid = (right - left) / 2 + left;
              //[5, 7, 7, 7, 8, 8, 10] l = 0 , r = 6 , m = 3 , tar = 7
              //由于要找左边界，所以nums[m] == tars时还要继续寻找左区间，故r = m - 1
              if(nums[mid] >= target){
                  //因为要寻找左边界，需要更新right，寻找左区间
                  right = mid - 1;
                  res = right;
              }else {
                  left = mid + 1;
              }
          }
          if(res + 1 >= 0 && res + 1 <= nums.length - 1 && nums[res + 1] == target){
              return res + 1;
          }else {
              return -1;
          }
      }
  ```


#### 2. 常用方法

##### 2.1 二分法

使用场景：给出一组有序的数组，**根据条件寻找某个（些）元素**

一般可以用二分法加速元素的查询，时间复杂度O(n^2)

##### 2.2 双指针

使用场景：**删除数组中的元素**，要求空间复杂度为O(1)

利用双指针，left指针为要覆盖的位置，right为探索指针，寻找位置为符合要求的元素，将right位置上的元素赋值给left位置，后移指针

##### 2.3 滑动窗口

使用场景：**寻找满足条件的子数组**

利用双指针确定一个窗口，通过双指针的移动，实现滑动窗口，在窗口不断的滑动（扩大并缩小）寻求满足条件的子数组

#### II. 链表

链表一般设计到一下几类题型：

- 移除链表元素：可以利用迭代以及递归的方式实现

- 设计链表：该链表可以满足在任意位置添加节点，删除指定val的节点

  - 可以通过单链表或双向链表作为底层数据结构
  - 单链表：实时维护链表的长度size，用于判定index合法性
  - 双向链表：空间换时间，维护一个头节点一个尾节点，可以根据index的位置从头或尾进行遍历，加快查询速率

- 翻转链表

  - 利用栈实现

    ```java
    	public ListNode reverseList(ListNode head) {
            Stack<ListNode> stack = new Stack<>();
            ListNode newRoot = new ListNode(0);
            ListNode temp = newRoot;
            while(head != null){
                stack.add(head);
                head = head.next;
            }
            while(!stack.isEmpty()){
                temp.next = stack.pop();
                temp = temp.next;
            }
            //不加这句会导致循环链表
            //在栈中的节点next会保存之间的next，需要初始化
            temp.next = null;
            return newRoot.next;
        }
    ```

  - 迭代方法

    ```java
    	public ListNode reverseList2(ListNode head) {
            ListNode cur = head;
            ListNode pre = null;
            while(cur != null){
                //需要暂存一下cur的下一个节点
                ListNode next = cur.next;
                //翻转指针
                cur.next = pre;
                //后移pre以及cur
                pre = cur;
                cur = next;
            }
            return pre;
        }
    ```

  - 递归方法

    ```java
    	public ListNode reverseList3(ListNode head) {
            if(head == null || head.next == null){
                return head;
            }
            ListNode newRoot = reverseList3(head.next);
            //l1 -> l2 翻转为 l1 <- l2
            head.next.next = head;
            //去引用，初始化
            head.next = null;
            return newRoot;
        }
    ```

- 两两交换链表中的节点

  - 可以通过迭代和递归的方式解决，核心代码类似于翻转链表

- 删除链表中的倒数第N个节点

  - 该类问题可以用**双指针**解决，具体思路为：first指针与second指针相隔n个距离，后同时移动双指针，当first遍历到尾部时，second.next位置即为删除位置

    ```java
    public ListNode removeNthFromEnd2(ListNode head, int n) {
            ListNode newRoot = new ListNode(-1);
            newRoot.next = head;
            ListNode first = head;
            ListNode second = newRoot;
            for(int i = 0; i < n; i++){
                first = first.next;
            }
            while(first != null){
                first = first.next;
                second = second.next;
            }
            second.next = second.next.next;
            return newRoot.next;
        }
    ```

- 寻找两链表相交的首节点

  - 该类问题可以用**双指针**解决，设立双指针分别指向headA与headB，指针tempA遍历完headA，再遍历headB；同时，指针tempB遍历完headB，再遍历headA，当指针重合时，即重合点

  - 理论：设headA链表长a，headB链表长b，重合部分长c；则 a + (b - c) = b + (a - c)

    ```java
    	public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {
            ListNode tempA = headA, tempB = headB;
            while(tempA != tempB){
                tempA = tempA == null ? headB : tempA.next;
                tempB = tempB == null ? headA : tempB.next;
            }
            return tempA;
        }
    ```

- 环形链表：寻找环入口

  - 该类问题可以用**双指针**解决，算法流程为：

    - 寻找第一次相遇位置（若有环存在）
    - slow继续从相遇位置移动，fast从链表头移动，同时一个一个移动，相遇位置为环入口

    ```java
    	public ListNode detectCycle3(ListNode head) {
            ListNode fast = head, slow = head;
            while(true) {
                if(fast == null || fast.next == null) {
                    return null;
                }
                fast = fast.next.next;
                slow = slow.next;
                if(slow == fast) break;
            }
            fast = head;
            while(slow != fast){
                slow = slow.next;
                fast = fast.next;
            }
            return fast;
        }
    ```


#### III. 哈希表

一般哈希表用来快速判断一个元素是否出现在集合中

- 用数组作为哈希表：一般常见于与单词有关的场景中，因为申请数组的长度是确定有界的
- 用set作为哈希表：如果题目中没有限制数值的大小，且有重复的元素那么可以使用set集，但是set只能存储一个key
- 用map作为哈希表：kv结构

##### 1. 常见题型

- 异位词相关题目：可以利用长度为26的数组作为哈希表，记录字母出现的个数
- 数组交集：由于数组中元素可能会重复，则可以使用set集
- n数之和：
  - 二数之和：利用hash表存储已访问过的元素，查询会降低到O(1)
  - 三数之和：先排序，确定第一个数，后利用双指针头尾逼近寻找剩余两个数O(n^2)
  - 四数之和：先排序，确定第一个数以及第二个数，后用双指针头尾逼近寻找剩余两个数O(n^3)
- 快乐数：利用hash表存储已经出现过的数，若循环到出现过的数那么一定不是快乐数

#### IV. 栈与队列

##### 1. 栈

要充分利用其后进先出的特性

经典题目：

- 括号匹配问题
- 字符串去重问题：可以利用StringBuilder模拟栈
- 逆波兰表达式：利用数组代替栈

注意很多问题使用java中已经封装好的stack会比较浪费时间，可以利用数组、StringBuilder等去模拟栈操作，实现空间时间加速

##### 2. 队列

队列问题一般多出现为优先队列，即小顶堆或大顶堆，可以利用堆实时维护k个符合要求的元素，降低时间复杂度

经典题目：

- 滑动窗口最大值
  - 维护大顶堆，在大顶堆中记录元素的值以及索引，在判定最大值过期时，可以利用索引以及当前窗口位置判定
  - 维护单调栈，更加节省空间，添加元素时，删除比该元素小的元素
- 求K个高频元素：实际上就是求前k个最大值问题
  - 首先利用Hash表记录元素出现的频次，将该问题转化为求前k个最大值问题，判定当前元素个数与堆顶元素个数的关系来维护大小为k的小顶堆

#### V. 二叉树

##### 1. 遍历方式

**深度优先遍历**：前序遍历、中序遍历、后序遍历

- 递归方式：中序遍历为例

  ```java
  		public List<Integer> inorderTraversal(TreeNode root) {
          List<Integer> ans = new ArrayList<>();
          DFS(root, ans);
          return ans;
      }
  
      public void DFS(TreeNode node, List<Integer> ans) {
          if(node == null) return;
  
          DFS(node.left, ans);
          ans.add(node.val);
          DFS(node.right, ans);
      }
  ```

- 迭代方式：借助栈实现迭代，类似于回溯

  ```java
  		//入栈顺序：左到右
  		public List<Integer> inorderTraversal(TreeNode root) {
          List<Integer> ans = new ArrayList<>();
          if(root == null) return ans;
          Stack<TreeNode> stack = new Stack<>();
          TreeNode cur = root;
          while(cur != null || !stack.isEmpty()) {
              if(cur != null) {
                  stack.add(cur);
                  cur = cur.left;
              }else {
                  cur = stack.pop();
                  ans.add(cur.val);
                  cur = cur.right;
              }
          }
          return ans;
      }
  ```

**广度优先遍历：**层序遍历

```java
		public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if(root == null) return ans;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            List<Integer> list = new ArrayList<>();
            while(len > 0) {
                len--;
                TreeNode cur = queue.poll();
                list.add(cur.val);
                if(cur.left != null) {
                    queue.add(cur.left);
                }
                if(cur.right != null) {
                    queue.add(cur.right);
                }
            }
            ans.add(list);
        }
        return ans;
    }
```

##### 2. 二叉树的属性

- 二叉树是否对称

- 最大深度

- 最小深度

- 完全二叉树节点个数，性质：

  - 若height(left) == height(right)，说明左子树已满，个数为2 ^ height(left) - 1，再计算右子树个数即可
  - 若height(left) != height(right)，说明右子树已满，个数为2 ^ height(right) - 1

- 判断是否为平衡二叉树

  - 自顶向下递归：

    ```java
    		public boolean isBalanced(TreeNode root) {
            if(root == null) {
                return true;
            }else {
                return Math.abs(height(root.left) - height(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
            }
        }
    
        public int height(TreeNode root) {
            if(root == null) {
                return 0;
            }else {
                return Math.max(height(root.left), height(root.right)) + 1;
            }
        }
    ```

  - 自底向上递归：

    ```java
    		public boolean isBalanced2(TreeNode root) {
            return getHeight(root) >= 0;
        }
    
        public int getHeight(TreeNode root) {
            if(root == null) return 0;
            int leftHeight = getHeight(root.left);
            int rightHeight = getHeight(root.right);
    
            //若该节点的左右子树已经不满足平衡二叉树，或自己已经不符合则直接返回-1
            if(leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {
                return -1;
            }else {
                return Math.max(leftHeight, rightHeight) + 1;
            }
        }
    ```

- 二叉树所有路径：递归，先序遍历

  - 注意java中传引用，对于集合数据结构需要回溯

- 左子叶之和：层序遍历，后序遍历

- 二叉树左下角的值：层序遍历，递归先左后右

- 二叉树路径总和

##### 3. 二叉树的修建与构造

- 翻转二叉树
- 构造二叉树：给出中序遍历以及前/后序遍历，构造二叉树
  - 基于前/后序遍历，确定根节点，切分中序遍历，递归构造
- 构造最大二叉树
- 合并两个二叉树

##### 4. BST的属性

- 二叉搜索树的搜索：按性质迭代搜索即可，迭代方式类似于链表移动指针
- 是否为二叉搜索树：
  - 按照性质：中序遍历为单调递增序列
  - 递归设置范围，超出范围则不为BST
- 二叉搜索树的最小绝对差：中序遍历
- 二叉搜索树的众数：中序遍历
- 二叉搜索树转为累加树：反序中序遍历

##### 5. 二叉树公共祖先问题

##### 6. 二叉搜索树的修改与构造

- 插入操作：迭代、递归

- 删除操作：寻找目标节点，针对四种情况进行删除

  ```java
  //找到目标节点，准备删除
  if(root.val == key) {
      //1. 如果该节点是叶子结点，直接删除
      if(root.left == null && root.right == null) {
      return null;
      }
      //2. 左叶子树为空，则删除后只剩下右子树
      if(root.left == null) {
      return root.right;
      }
      //3. 右子树为空，则删除后只剩下左子树
      if(root.right == null) {
      return root.left;
      }
      //4. 如果删除的节点存在左右子树
      TreeNode successor = root.right;
      while(successor.left != null) {
      successor = successor.left;
      }
      //删除successor，因为successor已经移动到根节点，不应该存在在root.right中
      root.right = deleteNode(root.right, successor.val);
      successor.right = root.right;
      successor.left = root.left;
      //删除了当前root节点，将successor作为当前新根
      return successor;
  }
  ```

- 修剪操作：根据上下限以及性质分条件遍历

- 构建二叉搜索树：每次寻找有序序列中间部分作为根，切分序列，分别进行递归

#### VI. 单调栈

一般题意为：寻找任意元素左或右第一个比其大（小）的元素，即可想到用单调栈进行解决

- 每日温度_739：寻找第一个较大元素的位置，维护下标单调递减栈
- 下一个更大元素I_496：寻找下一个更大元素，维护单调递减栈
- 下一个更大元素II_503：在循环队列中寻找下一个更大元素，遍历两遍即可
- 接雨水_42：
  - <img src="/Users/zyh/Library/Application Support/typora-user-images/image-20230207140849919.png" alt="image-20230207140849919" style="zoom:50%;" />
  - 维护下标单调递减栈，遍历数组，对于当前元素：
    - 若当前元素高于栈顶元素，且栈中元素至少有两个，则可以得到接雨水的区域。该区域的宽度为：（当前高度对应下标 - 距栈顶第二个元素下标 - 1），该区域的高度为（当前元素与第二个元素的高度最小值）- 栈顶高度
    - 将当前栈顶元素出栈，继续比较栈顶元素，以此类推
- 柱状图最大矩形_84：
  - 维护下标单调递增栈，以栈顶元素的高度为基准，当前元素小于栈顶元素，则为右边下一个更小元素；栈顶下一个元素，则为左边下一个更小元素



